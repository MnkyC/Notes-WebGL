**使用多个缓冲区对象向着色器传递多种数据，适合数据量不大的情况**

当顶点非常多时，我们就需要将顶点的坐标和尺寸数据打包到同一个缓冲区对象中，然后分别访问缓冲区对象中不同种类的数据

## gl.vertexAttribPointer(locaction, size, type, normalized, stride, offset)

- stride

  表示缓冲区对象中单个顶点的所有数据的字节数，即**步进参数**，当缓冲区有多种类型的数据时就需要考虑该参数的值

  假设每个顶点有3个数据值（两个坐标数据和一个尺寸数据），每个元素所占字节数为FSIZE，stride应设置为每项数据大小的三倍，即FSIZE * 3

- offset，表示当前考虑的数据项距离首个元素的距离，即**偏移参数**，如，顶点坐标数据放在最前，offset应设置为0；尺寸数据放在顶点坐标数据后，应设置为FSIZE * 2

## 修改颜色（varying变量）

**uniform变量可以将颜色信息传入片元着色器，但是，uniform变量是“一致”变量，是不可变的**，我们无法为每个顶点都准备一个值，故使用uniform变量时所有顶点都是同一个颜色

**varying变量的作用是从顶点着色器向片元着色器传输数据**

**varying变量只能是float(以及vec2, vec3, vec4, mat2, mat3, mat4)类型**

### 使用方式

1. 顶点着色器中，声明varying变量，并将attribute变量a_Color赋值给varying变量v_Color

   ```
   attribute vec4 a_Color;
   varying vec4 v_Color;
   void main() {
   	...
   	v_Color = a_Color;
   }
   ```

2. 片元着色器中，声明与顶点着色器中同名的varying变量即可，然后片元着色器将v_Color赋值给gl_FragColor

   ```
   varying vec4 v_Color;
   void main() {
   	gl_FragColor = v_Color;
   }
   ```

   **WebGL中，若顶点着色器和片元着色器中有类型和命名相同的varying变量，那么顶点着色器中赋值给改变量的值就会自动传入片元着色器中**

## 图形的装配和光栅化

顶点着色器和片元着色器之间的联系

### 图形装配

将孤立的顶点坐标装配成几何图形（图形的类型由gl.drawArrays()函数的第一个参数决定）

**顶点着色器中的gl_Position就是该阶段输入的数据**

几何图形的装配过程又称**图元装配过程**，装配出的基本图形（点，线，面）又称为**图元**

### 光栅化

将装配好的几何图形转化为片元

### 装配和光栅化过程

1. 执行顶点着色器，缓冲区对象中第一个坐标传递给attribute变量a_Position。一旦有一个顶点坐标被赋值给gl_Position，它就会进入图形装配区域，并暂时存储在装配区域
2. 依次执行顶点着色器（有几个顶点坐标就执行几次顶点着色器），全部执行完毕后，所有顶点坐标就都在装配区域了
3. 开始装配图形，使用传入的点坐标，根据gl.drawArrays()函数的第一个参数来决定如何装配
4. 显示在屏幕上的三角形由片元（像素）组成，还需要将图形转化为片元，这个过程就是光栅化。光栅化结束，就得到了组成三角形的所有片元

**光栅化后的片元数目就是三角形最终在屏幕上所覆盖的像素数**

## 调用片元着色器

光栅化结束，程序就会开始逐片元调用片元着色器，每调用一次处理一个片元

每个片元，片元着色器会计算该片元的颜色，并写入颜色缓冲区

最后一个片元处理完成，浏览器聚会显示出最终结果

### 内置变量

**gl_FragCoord**，该变量第1个和第2个分量表示片元在canvas坐标系中的坐标值

## 纹理映射

将一张图像映射到一个几何图形的表面上

这张图片被称为**纹理图像**或**纹理**

**纹理映射的作用，就是根据纹理图像，为之前光栅化后的每个片元涂上合适的颜色**

组成纹理图像的像素又称为**纹素**，每一个纹素的颜色都使用RGB或RGBA格式的编码

### WebGL纹理映射流程

1. 准备好映射到几何图形上的纹理图像

   可以是浏览器支持的任意格式的图像

2. 为几何图形配置纹理映射方式

   确定“几何图形的某个片元”的颜色如何取决于“纹理图像中哪个（或哪几个）像素”的问题

   这里我们利用图形的顶点坐标来确定屏幕上哪部分被纹理图像覆盖，利用**纹理坐标**来确定纹理图像的哪部分将覆盖到几何图形上

3. 加载纹理图像，对其进行配置，以在WebGL中使用它

4. 在片元着色器中将相应的纹素从纹理中抽取出来，将纹素的颜色赋给片元

### 纹理坐标

纹理图像上的坐标，通过纹理坐标可以在纹理图像上获取纹素颜色

为了区分纹理坐标和xy坐标，WebGL使用s和t命名纹理坐标（st坐标系统）

纹理图像四个角的坐标为左下角(0.0, 0.0)，右下角(1.0, 0.0)，右上角(1.0, 1.0)，左上角(0.0, 1,0)

纹理坐标的值和图像自身尺寸无关，右上角的纹理坐标始终是(1.0, 1.0)

### 纹理图像和几何图形的映射

纹理坐标（0.0, 1.0）映射到顶点坐标（-0.5, -0.5, 0.0）

纹理坐标（1.0, 1.0）映射到顶点坐标（0.5, 0.5, 0.0）

WebGL纹理坐标中的t轴的方向和PNG, BMP, JPG等格式图片的坐标系的Y轴方向相反，所以要先将图像Y轴进行反转，才能正确将图像映射到图形上

## 具体流程

1. 顶点着色器中接收顶点的纹理坐标，光栅化后传递给片元着色器

2. 片元着色器根据片元的纹理坐标，从纹理图像中抽取纹素颜色，赋给当前片元

3. 设置顶点的纹理坐标

   纹理坐标传入顶点着色器和其他顶点数据传入的方法相同

   ```
   var a_TexCoord = gl.getAttribLocation(gl.program, 'a_TexCoord');
   ```

4. 准备待加载的纹理图像，令浏览器读取它（配置和加载纹理）

   4.1 创建纹理对象（管理WebGL中的纹理）

   ```
   gl.createTexture();
   ```

   4.2 从片元着色器中获取uniform变量u_Sampler（取样器）的存储位置

   ```
   var u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');
   ```

   4.3 请求浏览器加载纹理图像供WebGL使用，该纹理图像会映射到矩形上，我们需要借助Image对象来使用

   ```
   var image = new Image();
   ```

   **必须用new操作符来新建Image对象**

   **加载图像是异步的**，所以需要监听加载完成事件

   ```
   image.onload = function() { loadTexture(gl, n, texture, u_Sapmler, image); };
   ```

   一旦浏览器完成了图像的加载，就会将得到的图像交给WebGL系统

   4.4 为WebGL配置纹理

5. 监听纹理图像的加载事件，一旦加载完成，就在WebGL中使用纹理

   使用流程

   5.1 使用图像前，将其进行Y轴反转

   ```
   gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
   ```

   5.2 激活纹理单元

   ​		WebGL通过**纹理单元**的机制来同时使用多个纹理，每个纹理单元有一个单元编号来管理一张纹理图像

   5.3 绑定纹理对象

   5.4 配置纹理对象的参数

   ​		以参数来设置纹理图像映射到图形上的具体方式（如何根据纹理坐标获取纹素颜色，按哪种方式重复填充纹理）

   5.5 将纹理图像分配给纹理对象

   5.6 将纹理单元传递给片元着色器

   ​		一旦将纹理图像传入WebGL系统，就必须将其传入片元着色器并映射到图形的表面上

   ​		我们用uniform变量来表示纹理，因为纹理图像不会随着片元变化

   ​		我们将表示纹理对象的uniform变量声明为一种特殊的，专用于纹理对象的数据类型**sampler2D**

经过上面这几步后，片元着色器就能访问纹理图像了





