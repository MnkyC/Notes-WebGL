# GLSL ES概述

GLSL ES是在OpenGL着色器语言**（GLSL）的基础上**，**删除和简化**一部分功能后形成的

## 基础

- 大小写敏感

- 语句以英文分号（;）结束

## 执行次序

从main()函数开始执行，着色器程序**必须有且仅有**一个main()函数，且main()函数不接收任何参数

main()函数前的void表示该函数不返回任何值

## 注释

单行注释：**//** 后知道换行处的所有字符都为注释

多行注释：**/*** 和 ***/** 之间的所有字符都为注释

## 数据值类型

- 数值类型

  **整型数**（没小数点）和**浮点数**（有小数点）

- 布尔值类型

- **不支持字符串类型**

## 变量

变量名要符合

- 只包含a-z, A-Z, 0-9和下划线
- 首字母不能是数字
- 不能是关键字和保留字，但可用于变量名的一部分
- 不能以 `gl_`、`webgl_`、 `_webgl_`开头

## GLSL ES是强类型语言

要求指明变量的数据类型

<类型> <变量名>

## 基本类型

float，单精度浮点数

int，整型数

bool，布尔值

## 赋值和类型转换

用等号（=）可以将值赋给变量，等号左右两侧的变量的类型要一致

整型数值要赋值给浮点型变量，需要进行类型转换

```
float f = float(8);
```

### 支持的类型转换

- 转整型数

  int(float)，小数部分删去

  int(bool)，true转为1，false转为0

- 转浮点数

  float(int)，8转为8.0

  float(bool)，true转为1.0，false转为0.0

- 转布尔值

  bool(int)，0转为false，其他非0值转为true

  bool(float)，0.0转为false，其他非0值转为true

## 运算符

取负

加减乘除

自增自减（前缀或后缀）

赋值

算术赋值，+=，-=，*=，/=

比较，<，>，<=，>=，==，!=

逻辑与（&&）或（||）非（!），异或（^^），支持短路运算

三元选择

## 矢量和矩阵

这两种类型的变量都包含多个元素，每个元素就是一个数值（整型数，浮点数或布尔值）

矢量可将这些元素排成一列，用来表示顶点坐标或颜色值等

矩阵可将这些元素分成行和列，用来表示变换矩阵

### 支持的类型

#### 矢量

vec2，vec3，vec4：具有2, 3, 4个浮点数元素

ivec2，ivec3，ivec4：具有2, 3, 4个整型数元素

bvec2，bvec3，bvec4：具有2, 3, 4个布尔值元素

#### 矩阵

mat2，mat3，mat4：2x2，3x3，4x4的浮点数元素的矩阵（分别有4，9，16个元素）

### 赋值和构造

矢量

```
vec3 v3 = vec3(1.0, 0.0, 0.5);
vec2 v2 = vec2(v3); // v2(1.0, 0.0)
vec4 v4 = vec(1.0); // v4(1.0, 1.0, 1.0, 1.0)
```

矩阵

要保证矩阵中的元素是按照**列主序**排列

### 访问元素

矢量或矩阵中的元素，可用`.`或 `[]`进行访问

矢量变量名后接点运算符，后接分量名即可访问矢量元素

[]运算符是通过数组下标来访问元素，从0开始，并且索引值必须是常量索引值（const修饰）

### 运算符

矢量和矩阵只可以用比较运算符中的`==`和`!=`

要比较大小就需要用内置函数（equal，notEqual，lessThan）

## 结构体

关键字struct，将已存在的类型聚合到一起，就可以定义为结构体

```
struct light {
	vec4 color;
	vec3 position;
}
light light1, light2; // 声明light类型的变量
```

### 赋值和构造

结构体的构造函数的参数顺序必须与结构体定义的成员顺序一致

```
light1 = light(vec4(0.0, 1.0, 0.0, 1.0), vec3(8.0, 2.0, 0.0));
```

### 访问成员

结构体变量名后跟点运算符（.）,后加上成员名就可以访问变量的成员

```
vec4 color = light1.color;
```

### 运算符

结构体成员可以参与自身类型支持的任何运算

结构体**本身只支持两种运算**，赋值（=）和比较（==，!=）

当且仅当两个结构体变量所对应的所有成员都相等时，两个结构体才相等

## 数组

**GLSL ES只支持一维数组，且数组对象不支持pop()和push()等操作**

创建数组不需要new运算符

声明数组只需要在变量名后加中括号（[]）和数组的长度即可

```
float floatArray[4];
vec4 vec4Array[2];
```

数组元素通过索引值来访问，索引值从0开始

数组**本身只支持[]运算符**，但数组元素可参与与其自身类型支持的任意运算

## 取样器（纹理）

必须通过取样器类型变量才能访问纹理

两种基本类型：**sampler2D**和**samplerCube**

取样器变量只能是uniform变量或者需要访问纹理的函数（texture2D()函数的参数）

**唯一能赋值给取样器变量的就是纹理单元编号**，且必须用WebGL方法`gl.uniform1i()`来赋值

除了=，==，!=，取样器变量不可以作为操作数参与运算

## 运算符优先级

## 分支和循环

### if和if-else

``` 
if (条件表达式1) {
	
} else if (条件表达式2) {

} else {

}
```

GLSL ES没有switch语句

**过多的if或if-else会降低着色器的执行速度**

### for

```
for (初始化表达式; 条件表达式; 循环步进表达式) {
	
}
```

### continue，break和discard

**continue和break只能在for语句中使用**

discard只能在片元着色器中使用，表示放弃当前片元直接处理下一个片元

## 函数

```
返回类型函数名 (type0 arg0, type1 arg1, ..., typen argn) {
	函数计算
	return 返回值;
}
```

### 规范声明

如果函数定义在其调用之后，那么必须在进行调用前先声明该函数的规范

规范预先告诉WebGL系统函数的参数，参数类型，返回值等

### 参数限定词

为函数参数指定限定字，可以控制参数的行为

## 内置函数

## 全局变量和局部变量

全局变量：变量声明在函数的外面

局部变量：变量声明在函数内部

## 存储限定字

### const变量

const限定了变量的值不能被改变

声明的同时必须对其进行初始化

```
const int speed = 200;
const vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
```

### attribute变量

**只能出现在顶点着色器中，只能被声明为全局变量**

用来表示逐顶点的信息

attribute变量的类型只能是float，vec2，vec3，vec4，mat2，mat3，mat4

### uniform变量

**可以出现在顶点着色器和片元着色器中，且必须是全局变量**

**uniform变量是只读的，可以是除了数组和结构体之外的任意类型**

顶点着色器和片元着色器中声明了同名的unifrom变量，那么它就会被两种着色器共享

uniform变量包含了“一致”（非逐顶点/逐片元的，各顶点或各片元共用）的数据

### varying变量

**同时出现在顶点着色器和片元着色器中，且必须是全局变量**

varying变量的任务是从顶点着色器向片元着色器传输数据，使用时必须在两种着色器中声明同名，同类型的varying变量

varying变量的类型只能是float，vec2，vec3，vec4，mat2，mat3，mat4



**attribute变量，uniform变量，varying变量，三者在WebGL系统中的数量限制都和设备有关**

## 精度限定字

目的是帮助着色器程序提高运行效率，削减内存开支

高精度的程序需要更大的开销（更大的内存和更久的计算时间）

使用精度限定字可以控制程序在效果和性能间的平衡

精度限定字是可选的，不确定就使用如下默认值

```
#ifdef GL_ES
precision mediump float; // 所有浮点数默认为中精度
#endif
```

WebGL支持三种精度，highp(高精度)，mediump(中精度)，lowp(低精度)

**除了片元着色器中的float类型没有默认精度，其他类型都实现了默认精度，所以我们必须手动指定**

### 默认精度

- 顶点着色器

  highp -> int，float

  lowp -> sampler2D，samplerCube

- 片元着色器

  mediump -> int

  lowp -> sampler2D，samplerCube

### 注意

- 某些WebGL环境中，片元着色器不支持高精度
- 数值范围和精度和系统环境有关

## 预处理指令

在真正编译前对代码进行预处理，都以井号（#）开始

```
#if 条件表达式
If 如果条件表达式为真，执行这里
#endif

#if 条件表达式
If 如果条件表达式为真，执行这里
#else
否则，执行这里
#endif

#ifdef 某宏
如果定义了某宏，执行这里
#endif

#ifndef 某宏
如果没有定义某宏，执行这里
#endif
```

可以用`#define`指令进行宏定义

```
#define 宏名 宏内容
```

可以用`#undef`指令解除宏定义

```
#undef 宏名
```